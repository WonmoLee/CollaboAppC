"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseUpdater = void 0;

function _bluebirdLst() {
  const data = require("bluebird-lst");

  _bluebirdLst = function () {
    return data;
  };

  return data;
}

function _AppUpdater() {
  const data = require("./AppUpdater");

  _AppUpdater = function () {
    return data;
  };

  return data;
}

class BaseUpdater extends _AppUpdater().AppUpdater {
  constructor(options, app) {
    super(options, app);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }

  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    var _this = this;

    return (0, _bluebirdLst().coroutine)(function* () {
      _this._logger.info(`Install on explicit quitAndInstall`);

      const isInstalled = yield _this.install(isSilent, isSilent ? isForceRunAfter : true);

      if (isInstalled) {
        setImmediate(() => {
          _this.app.quit();
        });
      } else {
        _this.quitAndInstallCalled = false;
      }
    })();
  }

  executeDownload(taskOptions) {
    var _this2 = this;

    return super.executeDownload(Object.assign({}, taskOptions, {
      done: function () {
        var _ref = (0, _bluebirdLst().coroutine)(function* (event) {
          _this2.dispatchUpdateDownloaded(event);

          _this2.addQuitHandler();
        });

        return function done(_x) {
          return _ref.apply(this, arguments);
        };
      }()
    }));
  } // must be sync (because quit even handler is not async)


  install(isSilent, isRunAfter) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");

      return false;
    }

    const installerPath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;

    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    } // prevent calling several times


    this.quitAndInstallCalled = true;

    try {
      this._logger.info(`Install: isSilent: ${isSilent}, isRunAfter: ${isRunAfter}`);

      return this.doInstall(installerPath, isSilent, isRunAfter);
    } catch (e) {
      this.dispatchError(e);
      return false;
    }
  }

  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }

    this.quitHandlerAdded = true;
    this.app.onQuit(exitCode => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");

        return;
      }

      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);

        return;
      }

      this._logger.info("Auto install update on quit");

      this.install(true, false);
    });
  }

} exports.BaseUpdater = BaseUpdater;
// __ts-babel@6.0.4
//# sourceMappingURL=BaseUpdater.js.map